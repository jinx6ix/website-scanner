import { createClient } from "@/lib/supabase/server"
import { spawn } from "child_process"

/**
 * Extended vulnerability scanner
 * - Crawls site (limited depth & breadth)
 * - Performs header, SSL, cookie checks
 * - Performs more exhaustive XSS/SQL fuzzing against discovered endpoints
 * - Supports simple authenticated scans via provided cookie or basic auth headers
 * - Attempts CVE mapping (via NVD API) if NVD_API_KEY is provided
 * - Can call external scanners (nmap/owasp-zap) if available on the host
 *
 * Notes:
 * - Running heavy scans (nmap, ZAP) in serverless environments (Vercel, Netlify) will not work.
 *   Use a dedicated worker (Docker) or background instance with proper binaries installed.
 * - This file focuses on safe, incremental improvements while remaining compatible with
 *   a Node.js server environment.
 */

interface VulnerabilityResult {
  type: string
  severity: "critical" | "high" | "medium" | "low"
  title: string
  description: string
  affectedUrl?: string
  recommendation: string
  cveId?: string | null
}

interface ScanOptions {
  crawlDepth?: number // how deep to follow links (default 2)
  maxPages?: number // maximum pages to visit (default 30)
  auth?: {
    type: "cookie" | "basic" | "bearer" | "none"
    header?: string // e.g., "cookie: name=val;"
    username?: string
    password?: string
    bearerToken?: string
  }
  runExternal?: boolean // attempt to run nmap/ZAP if true
}

const DEFAULT_OPTIONS: Required<Pick<ScanOptions, "crawlDepth" | "maxPages" | "auth" | "runExternal">> = {
  crawlDepth: 2,
  maxPages: 30,
  auth: { type: "none", header: undefined, username: undefined, password: undefined, bearerToken: undefined },
  runExternal: false,
}

const delay = (ms: number) => new Promise((r) => setTimeout(r, ms))

async function fetchWithRetry(url: string, options: RequestInit = {}, maxRetries = 3): Promise<Response | null> {
  const defaultOptions: RequestInit = {
    headers: {
      "User-Agent": "SecureScan/1.0",
      ...options.headers,
    },
    // AbortSignal.timeout is supported in newer runtimes; fallback handled if unavailable
    signal: (typeof AbortSignal !== "undefined" && (AbortSignal as any).timeout) ? (AbortSignal as any).timeout(15000) : undefined,
    ...options,
  }

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await fetch(url, defaultOptions)

      if (response.status === 429) {
        const waitTime = Math.pow(2, attempt) * 1000
        await delay(waitTime)
        continue
      }

      return response
    } catch (error) {
      if (attempt === maxRetries - 1) return null
      await delay(1000 * (attempt + 1))
    }
  }

  return null
}

/**
 * Entry point
 */
export async function performVulnerabilityScan(scanId: string, targetUrl: string, options?: ScanOptions) {
  const supabase = await createClient()
  const cfg = { ...DEFAULT_OPTIONS, ...(options || {}) }

  try {
    const visited = new Set<string>()
    const queue: { url: string; depth: number }[] = []
    const vulnerabilities: VulnerabilityResult[] = []

    // Normalize
    const startUrl = normalizeUrl(targetUrl)
    queue.push({ url: startUrl, depth: 0 })

    // Optionally run external scanners (best-effort)
    if (cfg.runExternal) {
      runExternalScanners(scanId, startUrl).catch((err) => console.error("[v0] external scanner error:", err))
    }

    while (queue.length > 0 && visited.size < cfg.maxPages) {
      const item = queue.shift()!
      if (visited.has(item.url)) continue
      visited.add(item.url)

      // Politeness delay
      await delay(200)

      // Use provided auth headers if set
      const requestHeaders: Record<string, string> = {}
      if (cfg.auth.type === "cookie" && cfg.auth.header) requestHeaders["cookie"] = cfg.auth.header
      if (cfg.auth.type === "basic" && cfg.auth.username && cfg.auth.password) {
        requestHeaders["authorization"] = `Basic ${Buffer.from(`${cfg.auth.username}:${cfg.auth.password}`).toString("base64")}`
      }
      if (cfg.auth.type === "bearer" && cfg.auth.bearerToken) requestHeaders["authorization"] = `Bearer ${cfg.auth.bearerToken}`

      // HEAD for headers
      const headResp = await fetchWithRetry(item.url, { method: "HEAD", headers: requestHeaders })
      if (headResp) {
        vulnerabilities.push(...await checkSecurityHeadersFromResponse(item.url, headResp))
        vulnerabilities.push(...await checkCookieSecurityFromResponse(item.url, headResp))
      }

      // Full GET for content-based checks and crawling
      const getResp = await fetchWithRetry(item.url, { method: "GET", headers: requestHeaders })
      if (!getResp) continue

      const text = await getResp.text()

      vulnerabilities.push(...await analyzeResponseForVulns(item.url, text, getResp, cfg))

      // Crawl links if depth < crawlDepth
      if (item.depth < cfg.crawlDepth) {
        const links = extractLinks(item.url, text)
        for (const l of links) {
          const norm = normalizeUrl(l)
          if (norm && norm.startsWith(startUrl) && !visited.has(norm) && queue.length + visited.size < cfg.maxPages) {
            queue.push({ url: norm, depth: item.depth + 1 })
          }
        }
      }
    }

    // Map potential CVEs based on headers/tech fingerprints (best-effort)
    const headerTech = inferTechFromHeaders(vulnerabilities)
    const cveMap = await mapCvesForTech(headerTech)
    // attach CVE ids where applicable (simple mapping logic)
    for (const v of vulnerabilities) {
      if (!v.cveId && cveMap[v.type]) v.cveId = cveMap[v.type][0] || null
    }

    // Count severities
    const criticalCount = vulnerabilities.filter((v) => v.severity === "critical").length
    const highCount = vulnerabilities.filter((v) => v.severity === "high").length
    const mediumCount = vulnerabilities.filter((v) => v.severity === "medium").length
    const lowCount = vulnerabilities.filter((v) => v.severity === "low").length

    await supabase.from("scans").update({
      scan_status: "completed",
      completed_at: new Date().toISOString(),
      total_vulnerabilities: vulnerabilities.length,
      critical_count: criticalCount,
      high_count: highCount,
      medium_count: mediumCount,
      low_count: lowCount,
    }).eq("id", scanId)

    if (vulnerabilities.length > 0) {
      const records = vulnerabilities.map((v) => ({
        scan_id: scanId,
        vulnerability_type: v.type,
        severity: v.severity,
        title: v.title,
        description: v.description,
        affected_url: v.affectedUrl || targetUrl,
        recommendation: v.recommendation,
        cve_id: v.cveId || null,
      }))

      await supabase.from("vulnerabilities").insert(records)
    }
  } catch (error) {
    console.error("[v0] Scan failed:", error)
    await supabase.from("scans").update({ scan_status: "failed", completed_at: new Date().toISOString() }).eq("id", scanId)
  }
}

/**
 * Analyze response body + headers for vulnerabilities: XSS reflection, SQL error patterns, insecure forms, etc.
 */
async function analyzeResponseForVulns(url: string, body: string, response: Response, cfg: Required<ScanOptions>) {
  const vulns: VulnerabilityResult[] = []

  // Basic XSS reflection (checks many payloads, not just the one)
  vulns.push(...await checkXSSAdvanced(url, body, cfg))

  // SQL injection heuristic checks (multiple params & payloads, blind detection via length/status differences)
  vulns.push(...await checkSQLInjectionAdvanced(url, body, cfg))

  // Insecure forms (presence of forms with action HTTP or missing autocomplete/password checks)
  if (body.includes("<form")) {
    if (url.startsWith("http://")) {
      vulns.push({
        type: "insecure_form",
        severity: "high",
        title: "Form served over HTTP",
        description: "A form was found on an HTTP page; credentials submitted from this form may be intercepted.",
        affectedUrl: url,
        recommendation: "Serve forms over HTTPS and enforce secure cookies/transport.",
        cveId: null,
      })
    }
  }

  return vulns
}

/**
 * Enhanced header checks using a Response object from fetch
 */
async function checkSecurityHeadersFromResponse(url: string, resp: Response): Promise<VulnerabilityResult[]> {
  const vulnerabilities: VulnerabilityResult[] = []
  try {
    const headers = resp.headers

    const headerChecks = [
      { name: "strict-transport-security", title: "Missing HSTS Header", severity: "high" as const },
      { name: "x-content-type-options", title: "Missing X-Content-Type-Options", severity: "medium" as const },
      { name: "x-frame-options", title: "Missing X-Frame-Options", severity: "medium" as const },
      { name: "content-security-policy", title: "Missing Content-Security-Policy", severity: "high" as const },
      { name: "referrer-policy", title: "Missing Referrer-Policy", severity: "low" as const },
      { name: "permissions-policy", title: "Missing Permissions-Policy", severity: "low" as const },
    ]

    for (const c of headerChecks) {
      if (!headers.has(c.name)) {
        vulnerabilities.push({
          type: "security_headers",
          severity: c.severity,
          title: c.title,
          description: `${c.title}: ${c.name} is not present in the response headers.`,
          affectedUrl: url,
          recommendation: `Add the ${c.name} header with an appropriate value to improve security.`,
          cveId: null,
        })
      }
    }

    // Additional checks for CSP value strength
    if (headers.has("content-security-policy")) {
      const csp = headers.get("content-security-policy") || ""
      if (csp.includes("unsafe-inline") || csp.includes("'unsafe-inline'")) {
        vulnerabilities.push({
          type: "csp",
          severity: "medium",
          title: "Relaxed Content-Security-Policy (unsafe-inline)",
          description: "CSP contains 'unsafe-inline', which weakens protection against XSS.",
          affectedUrl: url,
          recommendation: "Remove 'unsafe-inline' and use nonces/hashes for inline scripts.",
          cveId: null,
        })
      }
    }

  } catch (error) {
    console.error("[v0] Error checking security headers:", error)
  }
  return vulnerabilities
}

async function checkCookieSecurityFromResponse(url: string, resp: Response): Promise<VulnerabilityResult[]> {
  const vulnerabilities: VulnerabilityResult[] = []
  try {
    // Many servers send multiple Set-Cookie headers. Fetch API combines them as separate headers, but some runtimes combine.
    const raw = resp.headers.get("set-cookie")
    if (!raw) return vulnerabilities

    // split by comma carefully: simple split is OK for most cookies but may break on complex attributes. This is a pragmatic approach.
    const cookies = raw.split(/,(?=[^\s])/)

    for (const cookie of cookies) {
      const lc = cookie.toLowerCase()
      if (!lc.includes("secure")) {
        vulnerabilities.push({ type: "cookie_security", severity: "medium", title: "Cookie Missing Secure Flag", description: "Cookie missing Secure flag.", affectedUrl: url, recommendation: "Set Secure on cookies.", cveId: null })
      }
      if (!lc.includes("httponly")) {
        vulnerabilities.push({ type: "cookie_security", severity: "medium", title: "Cookie Missing HttpOnly Flag", description: "Cookie missing HttpOnly flag.", affectedUrl: url, recommendation: "Set HttpOnly to prevent JS access to session cookies.", cveId: null })
      }
      if (!lc.includes("samesite")) {
        vulnerabilities.push({ type: "cookie_security", severity: "low", title: "Cookie Missing SameSite", description: "Cookie missing SameSite attribute.", affectedUrl: url, recommendation: "Add SameSite=Lax or Strict.", cveId: null })
      }
    }
  } catch (error) {
    console.error("[v0] Error checking cookie security:", error)
  }
  return vulnerabilities
}

/**
 * Advanced XSS fuzzing: try multiple payloads across all query parameters and common POST endpoints.
 */
async function checkXSSAdvanced(urlStr: string, pageBody: string, cfg: Required<ScanOptions>): Promise<VulnerabilityResult[]> {
  const vulns: VulnerabilityResult[] = []
  try {
    const payloads = [
      "<script>alert(1)</script>",
      "\"'><script>alert(1)</script>",
      "<img src=x onerror=alert(1)>",
      "javascript:alert(1)",
      "<svg/onload=alert(1)>",
      "<iframe src='javascript:alert(1)'></iframe>",
    ]

    const url = new URL(urlStr)
    if (url.search.length === 0) return vulns

    const params = Array.from(new URLSearchParams(url.search).keys())
    for (const param of params) {
      for (const payload of payloads) {
        const testUrl = new URL(urlStr)
        const q = new URLSearchParams(testUrl.search)
        q.set(param, payload)
        testUrl.search = q.toString()

        const resp = await fetchWithRetry(testUrl.toString(), { method: "GET" })
        if (!resp) continue
        const text = await resp.text()
        if (text.includes(payload) || text.includes(escapeHtml(payload))) {
          vulns.push({
            type: "xss",
            severity: "high",
            title: "Reflected XSS detected",
            description: "Payload reflected in the response — possible reflected XSS.",
            affectedUrl: testUrl.toString(),
            recommendation: "Sanitize/encode output, use CSP and input validation.",
            cveId: null,
          })
          // break early for this param
          break
        }
        await delay(200)
      }
    }
  } catch (error) {
    console.error("[v0] Error in XSS advanced:", error)
  }
  return vulns
}

function escapeHtml(s: string) {
  return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;")
}

/**
 * Advanced SQL injection checks: test multiple parameters, many payloads, and try blind detection via response length/status differences.
 */
async function checkSQLInjectionAdvanced(urlStr: string, pageBody: string, cfg: Required<ScanOptions>): Promise<VulnerabilityResult[]> {
  const vulns: VulnerabilityResult[] = []
  try {
    const payloads = [
      "' OR '1'='1' -- ",
      "' OR '1'='1'/*",
      "1' OR '1'='1",
      "' UNION SELECT NULL--",
      "' AND SLEEP(5)--",
    ]

    const url = new URL(urlStr)
    if (url.search.length === 0) return vulns

    const params = Array.from(new URLSearchParams(url.search).keys())
    const baselineResp = await fetchWithRetry(urlStr, { method: "GET" })
    const baselineText = baselineResp ? await baselineResp.text() : ""

    for (const param of params) {
      for (const payload of payloads) {
        const testUrl = new URL(urlStr)
        const q = new URLSearchParams(testUrl.search)
        q.set(param, payload)
        testUrl.search = q.toString()

        const resp = await fetchWithRetry(testUrl.toString(), { method: "GET" })
        if (!resp) continue
        const text = await resp.text()

        // heuristic 1 — visible SQL error strings
        if (/sql syntax|mysql_fetch|ora-|postgresql|syntax error|sql error/i.test(text)) {
          vulns.push({ type: "sql_injection", severity: "critical", title: "SQL error strings detected", description: "Server returned database error messages when given SQL payloads.", affectedUrl: testUrl.toString(), recommendation: "Use parameterized queries and avoid verbose DB errors in responses.", cveId: null })
          break
        }

        // heuristic 2 — big content-length / response difference indicates blind SQLi might exist
        if (Math.abs(text.length - baselineText.length) > 200) {
          vulns.push({ type: "sql_injection", severity: "high", title: "Response length difference after payload", description: "Response changed significantly after SQL payload — possible injection point.", affectedUrl: testUrl.toString(), recommendation: "Review parameter handling and use prepared statements.", cveId: null })
          break
        }

        await delay(200)
      }
    }
  } catch (error) {
    console.error("[v0] Error in SQL advanced:", error)
  }
  return vulns
}

/**
 * Run external scanners if available. This spawns child processes and captures output.
 * Make sure host has binaries installed (nmap, zap-cli, or zap.sh). This is optional.
 */
async function runExternalScanners(scanId: string, target: string) {
  const supabase = await createClient()

  try {
    // Example: nmap vulnerability script (requires nmap installed with script db)
    await updateScanStatus(supabase, scanId, "running", "running external nmap scan")
    const nmapOutput = await spawnCommand("nmap", ["-sV", "--script=vuln", target], 60_000)
    if (nmapOutput) {
      await supabase.from("scans").update({ external_scan_output: (nmapOutput || "") }).eq("id", scanId)
      // NOTE: parsing nmap output to structured vulns is left as an exercise
    }
  } catch (error) {
    console.error("[v0] External scanner failed:", error)
  }
}

function spawnCommand(cmd: string, args: string[], timeout = 30_000): Promise<string | null> {
  return new Promise((resolve) => {
    try {
      const proc = spawn(cmd, args)
      let out = ""
      let err = ""
      const t = setTimeout(() => {
        proc.kill()
        resolve(out || err || null)
      }, timeout)

      proc.stdout.on("data", (d) => out += d.toString())
      proc.stderr.on("data", (d) => err += d.toString())
      proc.on("close", () => {
        clearTimeout(t)
        resolve(out || err || null)
      })
    } catch (e) {
      resolve(null)
    }
  })
}

async function updateScanStatus(supabase: any, id: string, status: string, meta?: string) {
  await supabase.from("scans").update({ scan_status: status, status_message: meta || null }).eq("id", id)
}

/**
 * Infer simple "technology" names from vulnerabilities or headers to lookup CVEs later.
 */
/*  function inferTechFromHeaders(vulns: VulnerabilityResult[]) {
  // This is a simple heuristic: if we found types like 'csp' or 'cookie_security' we don't have tech
  // In a real scanner you'd use server header, x-powered-by, or Wappalyzer-like fingerprints
  const tech: string[] = []
  // placeholder: user can extend by adding header-based analysis
  return tech
}
*/

/**
 * Best-effort CVE mapping: calls NVD (if NVD_API_KEY present). Returns mapping type -> [cveId,...]
 * NOTE: NVD has rate limits and requires an API key for high-rate usage. Provide process.env.NVD_API_KEY.
 */
async function mapCvesForTech(tech: string[]): Promise<Record<string, string[]>> {
  const map: Record<string, string[]> = {}
  if (!process.env.NVD_API_KEY || tech.length === 0) return map

  // Simple example: query NVD for each tech name. Real mapping needs product/vendor/version detection.
  for (const t of tech) {
    try {
      const q = encodeURIComponent(t)
      const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?keyword=${q}`
      const resp = await fetch(url, { headers: { "apiKey": process.env.NVD_API_KEY } })
      if (!resp) continue
      const json = await resp.json()
      const cves = (json.vulnerabilities || []).slice(0, 3).map((v: any) => v.cve.id)
      map[t] = cves
    } catch (e) {
      // ignore
    }
  }

  return map
}

/**
 * Crawl helpers
 */
function extractLinks(baseUrl: string, html: string): string[] {
  try {
    const links: string[] = []
    // quick-and-dirty link extraction
    const re = /href\s*=\s*['\"]([^'\"]+)['\"]/gi
    let m: RegExpExecArray | null
    while ((m = re.exec(html)) !== null) {
      let href = m[1]
      try {
        const u = new URL(href, baseUrl)
        links.push(u.toString())
      } catch (e) {
        // ignore
      }
    }
    return links
  } catch (error) {
    return []
  }
}

function normalizeUrl(u: string) {
  try {
    const url = new URL(u)
    // strip hash
    url.hash = ""
    // normalize trailing slash
    if (url.pathname.endsWith("/")) url.pathname = url.pathname.replace(/\/$/, "")
    return url.toString()
  } catch (e) {
    return u
  }
}

/**
 * Simple heuristic to associate vulnerabilities/types with tech names for CVE lookup
 */
function inferTechFromHeaders(vulns: VulnerabilityResult[] | any[]): string[] {
  // placeholder; in practice inspect `Server`, `X-Powered-By`, `Via`, etc.
  return []
}

// Re-export basic functions for unit testing/troubleshooting
export const _internal = {
  fetchWithRetry,
  checkXSSAdvanced,
  checkSQLInjectionAdvanced,
  extractLinks,
  normalizeUrl,
  spawnCommand,
}
